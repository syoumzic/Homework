# Техническое задание  
Дана строка S и строка Т. Требуется
найти все вхождения строки Т в строку S, т. е. указать все
позиции строки S, начиная с которых читается строка Т.

# Система
Тактовая чистота: 2,50 GHz  
Оперативная память: 8 Gb  
Операционная система: Windows 10 Pro  

# Вычислительные эксперименты
ТЕСТ 1. Увеличение длины строки, в которой ищется подстрока  

brute force  
9.8 millisconds  
16.75 millisconds  
23.65 millisconds  
30.75 millisconds  

hash  
8.75 millisconds  
15.4 millisconds  
25.05 millisconds  
31.2 millisconds  
___
ТЕСТ 2. Увеличение длины искомой подстроки  

brute force  
31.7 millisconds  
33.9 millisconds  
51.25 millisconds 
  
//время поиска не соотносится в отношении 5:12:23, ведь применена оптимизация: при первом несовпавшем символе прекращаем сравнение строк  
  
hash  
62.9 millisconds  
59.95 millisconds  
57.05 millisconds  
  
// время поиска не соотносится в отношении 5:12:23, по той же причине  
  
brute force  
47.2 millisconds  
51.75 millisconds  
  
hash  
41.05 millisconds  
31.5 millisconds  
___
ТЕСТ 3. Сравнение brute force и хэшей  
  
brute force  
1330.65 milliseconds  
12.8 milliseconds  
  
hash  
12.8 milliseconds  
13.15 milliseconds  
  
//bruit force нахождение a(x100)b в строке a(x1000000) затратил больше всего времени, ведь оптимизация не сработала и алгоритм перебирал всевозможные вхождения слова в строку. Bruit force для строки и ba(x100) в строке a(x1000000) сработала по времени примерно как hash функция. Эти алгоритмы для каждой итерации по строке выходили заранее, несравнивая слово целиком
